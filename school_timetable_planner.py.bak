# School Timetable Planner
# Requirements: tkinter, sqlite3, pandas, openpyxl (for Excel export)

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
import sqlite3
import json
import os
import pandas as pd
import calendar
from datetime import datetime

DB_FILE = 'timetable.db'
CONFIG_FILE = 'config.json'

# Initialize empty sets for tracking impacted and resolved cells
IMPACTED_CELLS = set()  # (class, section, day, period)
RESOLVED_CELLS = set()  # (class, section, day, period)

import tkinter as tk
from tkinter import ttk, messagebox, filedialog, simpledialog
import sqlite3
import json
import os
import pandas as pd
import calendar
from datetime import datetime

DB_FILE = 'timetable.db'
CONFIG_FILE = 'config.json'

# Helper to get group for a class
def get_class_group(config, class_name):
    groups = config.get('groups', [])
    for group in groups:
        if class_name in group.get('classes', []):
            return group
    return None

# Initialize empty sets for tracking impacted and resolved cells
IMPACTED_CELLS = set()  # (class, section, day, period)
RESOLVED_CELLS = set()  # (class, section, day, period)

# Default config
DEFAULT_CONFIG = {
    "classes": [f"Class {i+1}" for i in range(10)],
    "sections": ["A", "B", "C", "D"],
    "subjects": ["Math", "Science", "English", "History", "Geography"],
    "teachers": ["Teacher 1", "Teacher 2", "Teacher 3", "Teacher 4"],
    "periods_per_day": 7,
    "days": ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]
}

def load_config():
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, 'r') as f:
            return json.load(f)
    else:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(DEFAULT_CONFIG, f, indent=2)
        return DEFAULT_CONFIG

CONFIG = load_config()

# Database setup
conn = sqlite3.connect(DB_FILE)
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS timetable (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    class TEXT,
    section TEXT,
    day TEXT,
    period INTEGER,
    subject TEXT,
    teacher TEXT
)''')
conn.commit()


class TimetableApp:
    def __init__(self, root):
        self.root = root
        self.root.title("School Weekly Timetable Planner")
        self.root.geometry("1200x700")
        self.config = CONFIG
        self.selected_week = tk.IntVar(value=datetime.now().isocalendar()[1])
        self.selected_year = tk.IntVar(value=datetime.now().year)
        self.impacted_cells = IMPACTED_CELLS
        self.resolved_cells = RESOLVED_CELLS
        self.style = ttk.Style()
        self._set_theme()
        self.setup_ui()
        self.load_timetable()
    def show_teacher_subject_mapping(self):
        mapping = self.config.get('teacher_subjects', {})
        all_subjects = self.config.get('subjects', [])
        win = tk.Toplevel(self.root)
        win.title("Edit Teacher-Subject Mapping")
        win.geometry("500x600")
        frame = ttk.Frame(win)
        frame.pack(fill='both', expand=True, padx=10, pady=10)
        canvas = tk.Canvas(frame)
        scroll = ttk.Scrollbar(frame, orient='vertical', command=canvas.yview)
        scroll.pack(side='right', fill='y')
        canvas.pack(side='left', fill='both', expand=True)
        inner = ttk.Frame(canvas)
        canvas.create_window((0,0), window=inner, anchor='nw')
        canvas.configure(yscrollcommand=scroll.set)
        teacher_vars = {}
        def on_configure(event):
            canvas.configure(scrollregion=canvas.bbox('all'))
        inner.bind('<Configure>', on_configure)
        row = 0
        for teacher in self.config.get('teachers', []):
            ttk.Label(inner, text=teacher, font=("Segoe UI", 10, "bold")).grid(row=row, column=0, sticky='w', pady=2)
            var = tk.StringVar(value=", ".join(mapping.get(teacher, [])))
            entry = ttk.Entry(inner, textvariable=var, width=40)
            entry.grid(row=row, column=1, sticky='w', padx=5)
            teacher_vars[teacher] = var
            row += 1
        def save_mapping():
            new_mapping = {}
            for teacher, var in teacher_vars.items():
                # Split by comma, strip whitespace, only allow valid subjects
                subjects = [s.strip() for s in var.get().split(',') if s.strip() and s.strip() in all_subjects]
                new_mapping[teacher] = subjects
            self.config['teacher_subjects'] = new_mapping
            with open(CONFIG_FILE, 'w') as f:
                json.dump(self.config, f, indent=2)
            self.draw_grid()
            messagebox.showinfo("Saved", "Teacher-subject mapping updated.")
            win.destroy()
        btn_frame = ttk.Frame(win)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="Save", command=save_mapping).pack(side='left', padx=10)
        ttk.Button(btn_frame, text="Close", command=win.destroy).pack(side='right', padx=10)
    def mark_teacher_on_leave(self):
        # Dialog to select teacher and day
        teachers = self.config['teachers']
        days = [calendar.day_name[i] for i in range(5)]
        leave_win = tk.Toplevel(self.root)
        leave_win.title("Mark Teacher On Leave")
        ttk.Label(leave_win, text="Select Teacher:").grid(row=0, column=0, padx=5, pady=5)
        teacher_var = tk.StringVar()
        teacher_cb = ttk.Combobox(leave_win, textvariable=teacher_var, values=teachers, state='readonly')
        teacher_cb.grid(row=0, column=1, padx=5, pady=5)
        ttk.Label(leave_win, text="Select Day:").grid(row=1, column=0, padx=5, pady=5)
        day_var = tk.StringVar()
        day_cb = ttk.Combobox(leave_win, textvariable=day_var, values=days, state='readonly')
        day_cb.grid(row=1, column=1, padx=5, pady=5)
        def process_leave():
            teacher = teacher_var.get()
            day = day_var.get()
            if not teacher or not day:
                messagebox.showerror("Error", "Please select both teacher and day.")
                return
            self.export_impacted_classes(teacher, day)
            leave_win.destroy()
        ttk.Button(leave_win, text="Export Impacted Classes", command=process_leave).grid(row=2, column=0, columnspan=2, pady=10)

    def export_impacted_classes(self, teacher, day):
        # Find all slots for this teacher on this day, and allow manual reassignment with conflict check
        year = self.selected_year.get()
        week = self.selected_week.get()
        classes = self.config['classes']
        sections = self.config['sections']
        periods = self.config['periods_per_day']
        teacher_subjects = self.config.get('teacher_subjects', {})
        impacted = []
        for class_ in classes:
            for section in sections:
                for p in range(periods):
                    subj_var, teacher_var = self.entries[(class_, section, day, p)]
                    if teacher_var.get() == teacher:
                        subject = subj_var.get()
                        impacted.append({
                            'class': class_,
                            'section': section,
                            'period': p,
                            'subject': subject,
                            'old_teacher': teacher,
                            'subj_var': subj_var,
                            'teacher_var': teacher_var
                        })
        if not impacted:
            messagebox.showinfo("No Impact", f"No classes found for {teacher} on {day}.")
            return
        # Show a window to edit impacted cells
        win = tk.Toplevel(self.root)
        win.title(f"Reassign {teacher} on {day}")
        win.geometry("700x400")
        frm = ttk.Frame(win)
        frm.pack(fill='both', expand=True, padx=10, pady=10)
        canvas = tk.Canvas(frm)
        vscroll = ttk.Scrollbar(frm, orient='vertical', command=canvas.yview)
        vscroll.pack(side='right', fill='y')
        canvas.pack(side='left', fill='both', expand=True)
        inner = ttk.Frame(canvas)
        canvas.create_window((0,0), window=inner, anchor='nw')
        canvas.configure(yscrollcommand=vscroll.set)
        def on_configure(event):
            canvas.configure(scrollregion=canvas.bbox('all'))
        inner.bind('<Configure>', on_configure)
        row = 0
        teacher_entries = []
        for slot in impacted:
            class_, section, p, subject = slot['class'], slot['section'], slot['period'], slot['subject']
            ttk.Label(inner, text=f"{class_} {section} Period {p+1}", background="#ffcccc").grid(row=row, column=0, sticky='w', padx=2, pady=2)
            ttk.Label(inner, text=subject).grid(row=row, column=1, sticky='w', padx=2)
            # Dropdown for available teachers
            available_teachers = [t for t in self.config['teachers'] if t != teacher and subject in teacher_subjects.get(t,[])]
            # Remove teachers already assigned at this period in any class/section
            busy_teachers = set()
            for c2 in classes:
                for s2 in sections:
                    tval = self.entries[(c2, s2, day, p)][1].get()
                    if tval:
                        busy_teachers.add(tval)
            available_teachers = [t for t in available_teachers if t not in busy_teachers]
            tvar = tk.StringVar(value=slot['teacher_var'].get())
            cb = ttk.Combobox(inner, textvariable=tvar, values=available_teachers, width=18, state='readonly')
            cb.grid(row=row, column=2, padx=2)
            teacher_entries.append((slot, tvar, cb))
            row += 1
        def save_changes():
            # Check for conflicts
            assigned = {}
            for slot, tvar, cb in teacher_entries:
                class_, section, p = slot['class'], slot['section'], slot['period']
                new_teacher = tvar.get()
                if not new_teacher:
                    messagebox.showerror("Error", f"Please assign a teacher for {class_} {section} Period {p+1}")
                    return
                # Check if teacher is already assigned at this period in any class/section
                for c2 in classes:
                    for s2 in sections:
                        if (c2, s2, day, p) == (class_, section, day, p):
                            continue
                        tval = self.entries[(c2, s2, day, p)][1].get()
                        if tval == new_teacher:
                            messagebox.showerror("Conflict", f"Teacher {new_teacher} is already assigned at {c2} {s2} Period {p+1}")
                            return
                # Also check within this batch of changes
                key = (new_teacher, p)
                if key in assigned:
                    messagebox.showerror("Conflict", f"Teacher {new_teacher} assigned to multiple impacted slots at Period {p+1}")
                    return
                assigned[key] = True
            # If all checks pass, update the main grid
            for slot, tvar, cb in teacher_entries:
                slot['teacher_var'].set(tvar.get())
            self.draw_grid()  # Ensure grid is refreshed instantly
            messagebox.showinfo("Saved", "Impacted slots updated.")
            win.destroy()
        btn_frame = ttk.Frame(win)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="Save Changes", command=save_changes).pack(side='left', padx=10)
        ttk.Button(btn_frame, text="Cancel", command=win.destroy).pack(side='right', padx=10)


    def _set_theme(self):
        # Set a modern color theme
        self.root.configure(bg="#f0f4f8")
        self.style.theme_use('clam')
        self.style.configure('TFrame', background="#f0f4f8")
        self.style.configure('TLabel', background="#f0f4f8", font=("Segoe UI", 10))
        self.style.configure('Header.TLabel', background="#2d6cdf", foreground="#fff", font=("Segoe UI", 11, "bold"), anchor="center")
        self.style.configure('TButton', font=("Segoe UI", 10, "bold"), background="#2d6cdf", foreground="#fff")
        self.style.map('TButton', background=[('active', '#1b4e91')], foreground=[('active', '#fff')])
        self.style.configure('TCombobox', font=("Segoe UI", 10))
        self.style.configure('FancyCell.TFrame', background="#eaf0fa", borderwidth=1, relief="solid")
        self.style.configure('FancyCell.TLabel', background="#eaf0fa", font=("Segoe UI", 9))

    def setup_ui(self):
        # Fancy header
        header_frame = ttk.Frame(self.root)
        header_frame.pack(fill='x', padx=0, pady=(0, 5))
        header_label = ttk.Label(
            header_frame,
            text="Indian Heights School",
            font=("Segoe UI", 22, "bold"),
            background="#2d6cdf",
            foreground="#fff",
            anchor="center"
        )
        header_label.pack(fill='x', pady=(0, 10))

        # Top frame for week selection and config
        top_frame = ttk.Frame(self.root)
        top_frame.pack(fill='x', padx=10, pady=5)
        ttk.Label(top_frame, text="Year:").pack(side='left')
        year_entry = ttk.Entry(top_frame, textvariable=self.selected_year, width=6)
        year_entry.pack(side='left', padx=5)
        ttk.Label(top_frame, text="Week #: ").pack(side='left')
        week_entry = ttk.Entry(top_frame, textvariable=self.selected_week, width=4)
        week_entry.pack(side='left', padx=5)
        ttk.Button(top_frame, text="Go to Week", command=self.load_timetable).pack(side='left', padx=10)
        # Config buttons
        ttk.Button(top_frame, text="Edit Classes", command=self.edit_classes).pack(side='right', padx=5)
        ttk.Button(top_frame, text="Edit Sections", command=self.edit_sections).pack(side='right', padx=5)
        ttk.Button(top_frame, text="Edit Teachers", command=self.edit_teachers).pack(side='right', padx=5)
        ttk.Button(top_frame, text="Edit Subjects", command=self.edit_subjects).pack(side='right', padx=5)

        # Timetable action buttons in a new frame below config
        action_frame = ttk.Frame(self.root)
        action_frame.pack(fill='x', padx=10, pady=(0, 10))
        ttk.Button(action_frame, text="Export Weekly Excel", command=self.export_excel).pack(side='left', padx=5)
        ttk.Button(action_frame, text="Auto-Assign Teachers", command=self.auto_assign_week).pack(side='left', padx=5)
        ttk.Button(action_frame, text="Teacher On Leave", command=self.mark_teacher_on_leave).pack(side='left', padx=5)
        ttk.Button(action_frame, text="View Teacher-Subject Mapping", command=self.show_teacher_subject_mapping).pack(side='left', padx=5)
        ttk.Button(action_frame, text="Refresh", command=self.draw_grid).pack(side='left', padx=5)

        # Timetable grid with horizontal scrollbar
        container = ttk.Frame(self.root)
        container.pack(fill='both', expand=True, padx=10, pady=10)
        canvas = tk.Canvas(container, bg="#f0f4f8", highlightthickness=0)
        h_scroll = ttk.Scrollbar(container, orient='horizontal', command=canvas.xview)
        v_scroll = ttk.Scrollbar(container, orient='vertical', command=canvas.yview)
        self.grid_frame = ttk.Frame(canvas)
        self.grid_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        canvas.create_window((0, 0), window=self.grid_frame, anchor='nw')
        canvas.configure(xscrollcommand=h_scroll.set, yscrollcommand=v_scroll.set)
        canvas.pack(side='left', fill='both', expand=True)
        v_scroll.pack(side='right', fill='y')
        h_scroll.pack(side='bottom', fill='x')
        self.draw_grid()

    def draw_grid(self):
        # Always reload config to reflect any manual changes to sections, etc.
        self.config = load_config()
        for widget in self.grid_frame.winfo_children():
            widget.destroy()
        # Weekly grid: Days x Periods x Classes x Sections
        year = self.selected_year.get()
        week = self.selected_week.get()
        periods = self.config['periods_per_day']
        days = [calendar.day_name[i] for i in range(5)]  # Mon-Fri
        classes = self.config['classes']
        sections = self.config['sections']
        teacher_subjects = self.config.get('teacher_subjects', {})
        # Header row
        ttk.Label(self.grid_frame, text="Class", style='Header.TLabel', borderwidth=1, relief="solid", width=10).grid(row=0, column=0, sticky='nsew')
        ttk.Label(self.grid_frame, text="Section", style='Header.TLabel', borderwidth=1, relief="solid", width=8).grid(row=0, column=1, sticky='nsew')
        col = 2
        for d in days:
            for p in range(periods):
                ttk.Label(self.grid_frame, text=f"{d}\nP{p+1}", style='Header.TLabel', borderwidth=1, relief="solid", width=10).grid(row=0, column=col, sticky='nsew')
                col += 1
        # Timetable cells
        self.entries = {}
        self.teacher_cbs = {}
        self.cell_frames = {}  # NEW: Track cell frames for color update
        row = 1
        for class_ in classes:
            for section in sections:
                ttk.Label(self.grid_frame, text=class_, style='TLabel', borderwidth=1, relief="solid", width=10).grid(row=row, column=0, sticky='nsew')
                ttk.Label(self.grid_frame, text=section, style='TLabel', borderwidth=1, relief="solid", width=8).grid(row=row, column=1, sticky='nsew')
                col = 2
                for d in days:
                    for p in range(periods):
                        cell_key = (class_, section, d, p)
                        # Use tk.Frame for color support
                        highlight = None
                        if cell_key in getattr(self, 'impacted_cells', set()):
                            highlight = '#ffcccc'  # red
                        elif cell_key in getattr(self, 'resolved_cells', set()):
                            highlight = '#ccffcc'  # green
                        frame = tk.Frame(self.grid_frame, bg=highlight if highlight else '#eaf0fa', bd=1, relief="solid")
                        frame.grid(row=row, column=col, sticky='nsew')
                        subj_var = tk.StringVar()
                        teacher_var = tk.StringVar()
                        subj_cb = ttk.Combobox(frame, textvariable=subj_var, values=self.config['subjects'], width=8, state='readonly')
                        subj_cb.pack(side='top', fill='x', padx=1, pady=1)
                        teacher_entry = ttk.Entry(frame, textvariable=teacher_var, width=12)
                        teacher_entry.pack(side='top', fill='x', padx=1, pady=(0,2))
                        # Track frame for color update
                        self.cell_frames[cell_key] = frame
                        def on_teacher_change(event=None, key=cell_key):
                            # Mark cell as resolved (green) on teacher change
                            self.resolved_cells.add(key)
                            self.impacted_cells.discard(key)
                            self.cell_frames[key].configure(bg='#ccffcc')
                        teacher_entry.bind('<FocusOut>', on_teacher_change)
                        teacher_entry.bind('<Return>', on_teacher_change)
                        subj_cb.bind('<<ComboboxSelected>>', lambda e: None)
                        self.entries[cell_key] = (subj_var, teacher_var)
                        self.teacher_cbs[cell_key] = (teacher_entry, subj_var)
                        col += 1
                row += 1

    def save_timetable(self):
        # Remove old entries for this week
        year = self.selected_year.get()
        week = self.selected_week.get()
        days = [calendar.day_name[i] for i in range(5)]
        c.execute("DELETE FROM timetable WHERE day LIKE ?", (f"{year}-W{week:02d}-%",))
        for (class_, section, d, p), (subj_var, teacher_var) in self.entries.items():
            subject = subj_var.get()
            teacher = teacher_var.get()
            if subject and teacher:
                # Check for teacher conflict
                c.execute("SELECT * FROM timetable WHERE day=? AND period=? AND teacher=? AND NOT (class=? AND section=?)", (f"{year}-W{week:02d}-{d}", p, teacher, class_, section))
                if c.fetchone():
                    messagebox.showerror("Conflict", f"Teacher {teacher} already assigned at {d} Period {p+1}")
                    return
                c.execute("INSERT INTO timetable (class, section, day, period, subject, teacher) VALUES (?, ?, ?, ?, ?, ?)", (class_, section, f"{year}-W{week:02d}-{d}", p, subject, teacher))
        conn.commit()
        messagebox.showinfo("Saved", "Timetable saved successfully.")

    def load_timetable(self):
        year = self.selected_year.get()
        week = self.selected_week.get()
        days = [calendar.day_name[i] for i in range(5)]
        for (class_, section, d, p), (subj_var, teacher_var) in self.entries.items():
            subj_var.set("")
            teacher_var.set("")
        c.execute("SELECT class, section, day, period, subject, teacher FROM timetable WHERE day LIKE ?", (f"{year}-W{week:02d}-%",))
        for row in c.fetchall():
            class_, section, day, period, subject, teacher = row
            # Extract day name from day string
            d = day.split('-')[-1]
            if (class_, section, d, period) in self.entries:
                self.entries[(class_, section, d, period)][0].set(subject)
                self.entries[(class_, section, d, period)][1].set(teacher)


    def export_excel(self):
        year = self.selected_year.get()
        week = self.selected_week.get()
        days = [calendar.day_name[i] for i in range(5)]
        classes = self.config['classes']
        sections = self.config['sections']
        periods = self.config['periods_per_day']
        # Gather all data from UI, including blanks and multiple teachers
        data = []
        for class_ in classes:
            for section in sections:
                for d in days:
                    for p in range(periods):
                        subj_var, teacher_var = self.entries[(class_, section, d, p)]
                        teachers = [t.strip() for t in teacher_var.get().split(',') if t.strip()]
                        data.append({
                            "Class": class_,
                            "Section": section,
                            "Day": d,
                            "Period": p,
                            "Subject": subj_var.get(),
                            "Teachers": ', '.join(teachers)
                        })
        df = pd.DataFrame(data)
        file = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
        if file:
            with pd.ExcelWriter(file) as writer:
                for class_ in classes:
                    for section in sections:
                        subdf = df[(df['Class'] == class_) & (df['Section'] == section)]
                        if not subdf.empty:
                            pivot = subdf.pivot(index="Day", columns="Period", values=["Subject", "Teachers"])
                            pivot.columns = [f"P{col[1]+1} {col[0]}" for col in pivot.columns]
                            pivot.reset_index(inplace=True)
                            pivot.to_excel(writer, sheet_name=f"{class_}-{section}", index=False)
            messagebox.showinfo("Exported", f"Weekly timetable exported to {file}")

    def export_impacted_classes(self, teacher, day):
        # Find all slots for this teacher on this day, and allow manual reassignment with conflict check
        year = self.selected_year.get()
        week = self.selected_week.get()
        classes = self.config['classes']
        sections = self.config['sections']
        periods = self.config['periods_per_day']
        teacher_subjects = self.config.get('teacher_subjects', {})
        impacted = []
        for class_ in classes:
            for section in sections:
                for p in range(periods):
                    subj_var, teacher_var = self.entries[(class_, section, day, p)]
                    if teacher_var.get() == teacher:
                        subject = subj_var.get()
                        impacted.append({
                            'class': class_,
                            'section': section,
                            'period': p,
                            'subject': subject,
                            'old_teacher': teacher,
                            'subj_var': subj_var,
                            'teacher_var': teacher_var
                        })
        if not impacted:
            messagebox.showinfo("No Impact", f"No classes found for {teacher} on {day}.")
            return
        # Show a window to edit impacted cells
        win = tk.Toplevel(self.root)
        win.title(f"Reassign {teacher} on {day}")
        win.geometry("700x400")
        frm = ttk.Frame(win)
        frm.pack(fill='both', expand=True, padx=10, pady=10)
        canvas = tk.Canvas(frm)
        vscroll = ttk.Scrollbar(frm, orient='vertical', command=canvas.yview)
        vscroll.pack(side='right', fill='y')
        canvas.pack(side='left', fill='both', expand=True)
        inner = ttk.Frame(canvas)
        canvas.create_window((0,0), window=inner, anchor='nw')
        canvas.configure(yscrollcommand=vscroll.set)
        def on_configure(event):
            canvas.configure(scrollregion=canvas.bbox('all'))
        inner.bind('<Configure>', on_configure)
        row = 0
        teacher_entries = []
        for slot in impacted:
            class_, section, p, subject = slot['class'], slot['section'], slot['period'], slot['subject']
            ttk.Label(inner, text=f"{class_} {section} Period {p+1}", background="#ffcccc").grid(row=row, column=0, sticky='w', padx=2, pady=2)
            ttk.Label(inner, text=subject).grid(row=row, column=1, sticky='w', padx=2)
            # Dropdown for available teachers
            available_teachers = [t for t in self.config['teachers'] if t != teacher and subject in teacher_subjects.get(t,[])]
            # Remove teachers already assigned at this period in any class/section
            busy_teachers = set()
            for c2 in classes:
                for s2 in sections:
                    tval = self.entries[(c2, s2, day, p)][1].get()
                    if tval:
                        busy_teachers.add(tval)
            available_teachers = [t for t in available_teachers if t not in busy_teachers]
            tvar = tk.StringVar(value=slot['teacher_var'].get())
            cb = ttk.Combobox(inner, textvariable=tvar, values=available_teachers, width=18, state='readonly')
            cb.grid(row=row, column=2, padx=2)
            teacher_entries.append((slot, tvar, cb))
            row += 1
        def save_changes():
            # Check for conflicts
            assigned = {}
            for slot, tvar, cb in teacher_entries:
                class_, section, p = slot['class'], slot['section'], slot['period']
                new_teacher = tvar.get()
                if not new_teacher:
                    messagebox.showerror("Error", f"Please assign a teacher for {class_} {section} Period {p+1}")
                    return
                # Check if teacher is already assigned at this period in any class/section
                for c2 in classes:
                    for s2 in sections:
                        if (c2, s2, day, p) == (class_, section, day, p):
                            continue
                        tval = self.entries[(c2, s2, day, p)][1].get()
                        if tval == new_teacher:
                            messagebox.showerror("Conflict", f"Teacher {new_teacher} is already assigned at {c2} {s2} Period {p+1}")
                            return
                # Also check within this batch of changes
                key = (new_teacher, p)
                if key in assigned:
                    messagebox.showerror("Conflict", f"Teacher {new_teacher} assigned to multiple impacted slots at Period {p+1}")
                    return
                assigned[key] = True
            # If all checks pass, update the main grid and color cells green
            for slot, tvar, cb in teacher_entries:
                slot['teacher_var'].set(tvar.get())
                # Mark cell as resolved (green)
                key = (slot['class'], slot['section'], day, slot['period'])
                self.resolved_cells.add(key)
                self.impacted_cells.discard(key)
                if hasattr(self, 'cell_frames') and key in self.cell_frames:
                    self.cell_frames[key].configure(bg='#ccffcc')
            self.draw_grid()  # Ensure grid is refreshed instantly
            messagebox.showinfo("Saved", "Impacted slots updated.")
            win.destroy()
        btn_frame = ttk.Frame(win)
        btn_frame.pack(fill='x', pady=5)
        ttk.Button(btn_frame, text="Save Changes", command=save_changes).pack(side='left', padx=10)
        ttk.Button(btn_frame, text="Cancel", command=win.destroy).pack(side='right', padx=10)
